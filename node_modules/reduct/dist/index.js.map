{"version":3,"file":"index.js","sourceRoot":"","sources":["../index.ts"],"names":[],"mappings":"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","sourcesContent":["import * as utility from './util'\n\nexport type Injector = {\n  <T>(Constructor: new(injector: Injector) => T): T\n  later: (fn: Function) => number\n  setOverride: (Constructor: Function, instance: any) => void\n}\n\nexport type InjectorPartial = {\n  <T>(Constructor: new(injector: Injector) => T): (T | undefined)\n  later?: (fn: Function) => number\n  setOverride?: (Constructor: Function, instance: any) => void\n}\n\nexport interface Constructor {\n  new (injector: Injector): Object\n}\n\nexport interface InstanceMap extends Map<Constructor, any> {\n  get<T> (key: new(injector: Injector) => T): T | undefined\n  set<T> (key: new(injector: Injector) => T, value: T): this\n}\n\ninterface MainExport {\n  (parent?: Injector | InstanceMap | Object): Injector\n  default: MainExport\n  util: typeof utility\n}\n\nconst createContainer = <MainExport>function (\n  parent?: Injector | InstanceMap | Object\n) {\n  let parentInjector: InjectorPartial\n  // Convenience: If a Map is passed as a parent injector, convert it\n  if (parent instanceof Map) {\n    parentInjector = key => parent.get(key)\n  // Convenience: If an object is passed as a parent injector, convert it\n  } else if (typeof parent === 'object') {\n    parentInjector = key => parent[key.name]\n  } else if (typeof parent === 'function') {\n    parentInjector = parent\n  } else if (typeof parent === 'undefined') {\n    parentInjector = () => undefined\n  } else {\n    throw new TypeError('Parent injector must be a Map, object or function')\n  }\n\n  const cache: InstanceMap = new Map()\n  const mapping: Map<Constructor, Constructor> = new Map()\n  let stack: Set<string | Function> = new Set()\n  let queue: Function[] = []\n\n  const construct = <T>(Constructor: new (injector: Injector) => T): T => {\n    const OverrideConstructor = mapping.get(Constructor)\n    return new (OverrideConstructor || Constructor)(reduct as Injector) as T\n  }\n\n  const reduct: InjectorPartial = <T>(Constructor: new (injector: Injector) => T): T => {\n    if (typeof Constructor !== 'function') {\n      throw new TypeError('Dependencies must be constructors/factories, but got: ' + typeof Constructor)\n    }\n\n    if (stack.has(Constructor)) {\n      const stackArray = utility.convertSetToArray(stack)\n      stackArray.push(Constructor)\n      const prettyStack = stackArray.map(utility.printPrettyConstructor).join(' => ')\n      throw new Error('Circular dependency detected: ' + prettyStack)\n    }\n\n    // First, check for an already cached instance\n    const cachedInstance = cache.get(Constructor) as T\n    if (cachedInstance) {\n      return cachedInstance\n    }\n\n    stack.add(Constructor)\n\n    const instance =\n      parentInjector(Constructor) ||   // Then try the parent SinjectorS\n      construct(Constructor)           // Finally, construct a new instance\n\n    stack.delete(Constructor)\n\n    // Cache the instance\n    cache.set(Constructor, instance)\n\n    // Run any registered post-constructors\n    if (queue.length) {\n      stack.add(utility.printPrettyConstructor(Constructor) + ' (post)')\n      const lastQueue = queue\n      queue = []\n      lastQueue.forEach((fn) => fn())\n    }\n\n    return instance\n  }\n\n  reduct.setOverride = (Constructor: Constructor, OverrideConstructor: Constructor) => {\n    mapping.set(Constructor, OverrideConstructor)\n  }\n  reduct.later = (fn: Function) => queue.push(fn)\n\n  return reduct as Injector\n}\n\ncreateContainer.default = createContainer\ncreateContainer.util = utility\nexport default createContainer\n\nmodule.exports = createContainer\n"]}